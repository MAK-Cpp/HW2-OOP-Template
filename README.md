# Домашнее задание №2 и №3

> [!WARNING]
> ПОКА НЕ СДЕЛАННО 2-е ДОМАШНЕЕ ЗАДАНИЕ И НЕ ПРОВЕРЕНО, ТРЕТЬЕ ДЕЛАТЬ НЕЛЬЗЯ!

## Как сдавать домашнее задание

Сначала делается второе дз в новой ветке `hw2`, после чего создается pull request в `master`. Только после того, как
pull request будет approve, можно сделать merge веток и уже после этого делать новую ветку `hw3`, после чего все шаги
повторяются.

### Задание №2. Экспоненциальная форма

Необходимо реализовать класс числа в экспоненциальной форме с десятичным основанием (
класс [Exponential](libs/exponential/include/Exponential.h)).
Такое число состоит из двух компонент: мантиссы (significand) и экспоненты (exponent).
Например, число `12.345` представляется мантиссой `12345` и экспонентой `-3`.

Будем называть число в экспоненциальной форме _нормализованным_, если мантисса не делится на 10 или равна нулю.
В этом задании от вас требуется, чтобы все операции возвращали именно такие числа.

Интерфейс класса должен состоять из следующих операций:

- Конструирование без аргументов
- Конструирование от `long long int`
- Конструирование от мантиссы и экспоненты (типа `long long int`)
- Мантисса: `long long int significand()`
- Экспонента: `long long int exponent()`
- Явное приведение к `double`
- Перевод в строку: `std::string str()`
- Сложение: `+`, `+=`
- Вычитание: `-`, `-=`
- Умножение: `*`, `*=`
- Деление: `/`, `/=`
- Унарный минус: `-`
- Сравнение на равенство: `==`, `!=`
- Вывод в поток: `<<`

Операции стоит реализовывать так, чтобы минимизировать вероятность переполнения.

Допустимо добавление в публичный интерфейс дополнительных методов, если они семантически действительно должны быть
публичными.

### Задание №3. Арифметические выражения

Необходимо организовать иерархию классов для работы с вычислимыми арифметическими выражениями над типом [Exponential](libs/exponential/include/Exponential.h).

Виды выражений:

- `Const` (в конструкторе передаётся значение)
- `Variable` (в конструкторе передаётся имя переменной)
- `Negate` (унарный минус)
- `Add` (сложение)
- `Subtract` (вычитание)
- `Multiply` (умножение)
- `Divide` (деление)

Все эти классы должны (необязательно напрямую) наследоваться от [Expression](libs/expression/include/Expression.h).

Пример конструирования выражения `2 * x + 1`:

```cpp
const Add expr(Multiply(Const(2), Variable("x")), Const(1));
```

Над выражениями должны быть реализованы соответствующие арифметические операторы.
Таким образом, предыдущий пример можно было бы записать так:

```cpp
const Add expr = Const(2) * Variable("x") + Const(1);
```

Аргументом методу `eval` передаётся отображение из имени переменной в её значение.
Он возвращает результат выражения, используя переданные значения вместо переменных.

```cpp
const Exponential result = expr.eval({
    {"x", Exponential(100)}
    {"y", Exponential(42)}
}); // 201
```

Вспомогательный метод `clone` должен возвращать указатель на такое же выражение, как то, на котором он вызван,
однако владение над указателем принадлежит вызвавшему метод (то есть необходимо создать другое выражение, которое в
точности повторяет исходное и вернуть на него указатель).

Для класса [Expression](libs/expression/include/Expression.h) должен быть реализован оператор вывода в поток

```cpp
std::ostream& operator<<(std::ostream& op, Expression const& expression) {
  ...
}
```
